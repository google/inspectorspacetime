/* #############################################################################
 *
 *  __  __       _   _             ____  _
 * |  \/  | ___ | |_(_) ___  _ __ |  _ \| | __ _ _   _  ___ _ __
 * | |\/| |/ _ \| __| |/ _ \| '_ \| |_) | |/ _` | | | |/ _ \ '__|
 * | |  | | (_) | |_| | (_) | | | |  __/| | (_| | |_| |  __/ |
 * |_|  |_|\___/ \__|_|\___/|_| |_|_|   |_|\__,_|\__, |\___|_|
 *                                               |___/
 *
 * MotionPlayer.js
 *
 * Description:
 * Advanced video controls for HTML5 video. Variable-speed playback, as well as
 * frame-by-frame browsing of videos
 *
 * Author:
 * dillongrove@google.com
 *
 * CONFIDENTIAL: For internal use at Google, Inc.
 *
 * #############################################################################
 *
 * TODO:
 *
 * [ ] Make sure markedZones are valid (do not pass the duration of the video,
 *     do not overlap)
 *
 * ########################################################################## */


/**
 * @constructor
 *
 * The primary constructor. This function is responsible for merging passed in
 * options with defaults, setting a few properties on the instance, and
 * initializing the plugin.
 *
 * @param    {Node}        element
 * @param    {Object}?     options
 *
 * @returns  {undefined}
 */
var MotionPlayer = function(element, options) {
  // TODO: handle string selector passed in to the constructor?

  // set state-related properties

  // merge passed in options with defaults
  this.options = this.__extend({}, this._getDefaults(), options);

  this._init();
};

MotionPlayer.prototype = {

  /*---------------------------------------------------------------------------/
  |   UTILTIY FUNCTIONS                                                       /
  ---------------------------------------------------------------------------/
  |   Functions that shouldn't need access to the MotionPlayer instance           /
   -----------------------------------------------------------------------*/

  /**
   * Similar to a very limited jQuery $ selector. Essentially an alias for
   * querySelectorAll
   *
   * @param    {String}      selector
   *
   * @returns  {NodeList}
   */
  __$: function(selector) {
    return document.querySelectorAll(selector);
  },

  /**
   * Similar to jQuery find(). Given an element, looks down the DOM tree for
   * anything matching the given selector.
   *
   * @param    {Node}        element
   * @param    {String}      selector
   *
   * @returns  {NodeList}
   */
  __find: function(element, selector) {
    return element.querySelectorAll(selector);
  },

  /**
   * Similar to jQuery addClass. Given a node and a class, adds that class to
   * the node's class list
   *
   * @param    {Node}        element
   * @param    {String}      className
   */
  __addClass: function(element, className){
    if (element.classList){
      element.classList.add(className);
    } else {
      element.className += ' ' + className;
    }
  },

  /**
   * Similar to jQuery removeClass. Given a node and a class, removes that class
   * from the node's class list
   *
   * @param    {Node}        element
   * @param    {String}      className
   */
  __removeClass: function(element, className){
    if (element.classList){
      element.classList.remove(className);
    } else {
      element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
    }
  },

  /**
   * Adds an eventListener for every Node in the specified NodeList
   *
   * @param    {NodeList}    list
   * @param    {String}      event
   * @param    {Function}    fn
   */
  __addEventListenerList: function(list, event, fn) {
      for (var i = 0, len = list.length; i < len; i++) {
          list[i].addEventListener(event, fn, false);
      }
  },

  /**
   * If this function receives a Node, it will simply return that. If it returns
   * a NodeList, it will return the first Node in that NodeList. This function
   * is used to allow other functions to accept either a Node or NodeList
   * without having to figure out which it has.
   *
   * @param    {Node/NodeList}   nodeOrNodeList
   *
   * @returns  {String}
   */
  __getFirstNode: function(nodeOrNodeList) {
    if(nodeOrNodeList instanceof Node){
      return nodeOrNodeList;
    } else if (nodeOrNodeList instanceof NodeList){
      return nodeOrNodeList[0];
    } else {
      throw new Error (arguments.callee.caller.name + " requires either a " +
          "Node or NodeList.");
    }
  },

  /**
   * Given an array, non-destructively returns a reversed copy of that array.
   * (Built-in Array.prototype.reverse is destructive)
   *
   * @param    {Array}       array
   *
   * @return   {Array}
   */
  __getReversed: function(array) {
    var temp = [];
    var len = array.length;

    for (var i = (len-1); i >= 0; i--) {
        temp.push(array[i]);
    }

    return temp;
  },

  /**
   * Given a total number of seconds, returns the parsed values of hours,
   * minutes, seconds, milliseconds
   *
   * @param    {Number}      totalSeconds
   *
   * @returns  {Object}
   */
  __getTimeObject: function(totalSeconds){
    var hours = parseInt( totalSeconds / 3600 ) % 24;
    var minutes = parseInt( totalSeconds / 60 ) % 60;
    var seconds = Math.floor(totalSeconds % 60);
    var ms = Math.round((totalSeconds * 1000) % 1000);

    if(hours > 0){
      var hoursStr = (hours < 10 ? "0" + hours : "" + hours);
    }

    var minutesStr = (minutes < 10 ? "0" + minutes : "" + minutes);
    var secondsStr = (seconds < 10 ? "0" + seconds : "" + seconds);

    if(ms < 10){
      var msStr = "00" + ms;
    } else if (ms < 100){
      var msStr = "0" + ms;
    } else {
      var msStr = "" + ms;
    }

    return {
      hours: hours,
      minutes: minutes,
      seconds: seconds,
      ms: ms,
      hoursStr: hoursStr,
      minutesStr: minutesStr,
      secondsStr: secondsStr,
      msStr: msStr
    }
  },

  /**
   * Given a string "path", returns the filename at the end of that path
   * TODO: Improve this function, it's not very robust as-is.
   *
   * @param    {String}      path
   *
   * @returns  {String}
   */
  __getFileFromPath: function(path){
    return path.substring(path.lastIndexOf('/')+1);
  },

  /**
   * Given a node, returns all data- attributes on it as an object
   *
   * @param    {Node}        el
   *
   * @returns  {Object}
   */
  __getDataAttributess: function(el){
    // shamelessly stolen from http://jsfiddle.net/3KFYf/
    var data = {};
    [].forEach.call(el.attributes, function(attr) {
        if (/^data-/.test(attr.name)) {
            var camelCaseName = attr.name.substr(5).replace(/-(.)/g, function ($0, $1) {
                return $1.toUpperCase();
            });
            data[camelCaseName] = attr.value;
        }
    });
    return data;
  },

  /**
   * Similar to jQuery extend, but without the deep option.
   * See: http://youmightnotneedjquery.com/#extend
   *
   * @param    {Object}?     out
   *
   * @returns  {Object}
   */
  __extend: function(out) {
    out = out || {};

    for (var i = 1; i < arguments.length; i++) {
      if (!arguments[i])
        continue;

      for (var key in arguments[i]) {
        if (arguments[i].hasOwnProperty(key))
          out[key] = arguments[i][key];
      }
    }

    return out;
  },


  /*---------------------------------------------------------------------------/
  |   PSEUDO-PRIVATE FUNCTIONS                                                /
  ---------------------------------------------------------------------------/
  |   These functions shouldn't be accessed from outside the plugin         /
   -----------------------------------------------------------------------*/

  /**
   * Returns an object containing the default parameters for the plugin.
   *
   * @returns   {Object}
   */
  _getDefaults: function() {
    return {
      playAfterSeek: false,
      videoTimeUpdateGranularity: 30
    }
  },

  /**
   * Initializes an instance of the plugin, attaching event handlers, populating
   * some plugin data, and running other first-run tasks.
   *
   * @returns  {undefined}
   */
  _init: function() {

    this.videos = this._getVideos();
    this._initVideos();

  },

  /**
   * Returns all eligible video nodes for the MotionPlayer. If the user has
   * passed in a triggerClass, only <video> tags with that class will be
   * selected. Otherwise, all <video>'s are selected
   *
   * @returns  {Array}
   */
  _getVideos: function() {
    if(this.options.triggerClass){
      var videoNodeList = this.__$("video." + this.options.triggerClass);
    } else {
      var videoNodeList = this.__$("video");
    }

    // turn the NodeList into an array
    return Array.prototype.slice.call(videoNodeList);
  },

  /**
   * Attaches relevant event handlers to all videos in this.videos
   *
   * @returns  {undefined}
   */
  _initVideos: function(){
    var self = this;

    // for each video
    self.videos.forEach(function(videoNode, i){
      // attach a click handler
      videoNode.addEventListener("click", function(e){
        // get the video src and data attributes
        var videoSrc = this.src;
        var videoData = self.__getDataAttributess(videoNode);

        // TODO: Do something here if the video has no src tag
        self._openAdvancedPlayer(videoSrc, videoData);
      }, false);
    });
  },

  /**
   * Opens an advanced player for the specified video
   *
   * @param    {String}       videoSrc
   * @param    {Object}       videoData
   *
   * @returns  {undefined}
   */
  _openAdvancedPlayer: function(videoSrc, videoData){
    var advancedPlayer = this._createAdvancedPlayer(videoSrc, videoData);

    // append the advancedPlayer
    this.__$("body")[0].appendChild(advancedPlayer);
  },

  /**
   * Closes the advanced player by removing it from the DOM
   *
   * @returns   {undefined}
  */
  _closeAdvancedPlayer: function(){
    var self = this;

    // unbind keyboard shortcuts
    self._unbindKeyboardShorcuts();

    var advancedPlayer = document.getElementById("mp__advancedPlayer");
    self.__$("body")[0].removeChild(advancedPlayer);
  },

  /**
   * Creates an advanced player for the specified video
   *
   * @param    {String}       videoSrc
   * @param    {Object}       videoData
   *
   * @returns  {Node}
  */
  _createAdvancedPlayer: function(videoSrc, videoData){
    var self = this;

    // create the overlay (top-level) div
    var advancedPlayer = document.createElement("div");
    advancedPlayer.id = "mp__advancedPlayer";

    self.__addClass(advancedPlayer, "mp__zoom-fill");

    // attach event handlers for the advancedPlayer
    advancedPlayer.addEventListener("click", function(e){
      self._closeAdvancedPlayer();
    }, false);

    // first, make the videoNode using the src passed in
    var videoNode = self._createVideoTag(videoSrc);

    // then, make the other parts of the UI using this videoNode
    var titleBarContainer =
        self._createTitleBarContainer(videoNode, videoData);
    var videoControlsContainer =
        self._createVideoControls(videoNode, videoData);

    advancedPlayer.appendChild(titleBarContainer);
    advancedPlayer.appendChild(videoNode);
    advancedPlayer.appendChild(videoControlsContainer);

    return advancedPlayer;
  },

  /**
   * Creates the title bar for advanced player
   *
   * @param    {Node}         videoNode
   * @param    {Object}       videoData
   *
   * @returns  {Node}
  */
  _createTitleBarContainer: function(videoNode, videoData){
    var self = this;

    var videoSrc = videoNode.src;

    var titleBar = document.createElement("div");
    titleBar.id = "mp__title-bar";
    var titleText = self.__getFileFromPath(videoSrc);
    titleBar.innerHTML = titleText;

    // prevent any click that gets to the titleBar from
    // propagating up any farther and closing the player
    titleBar.addEventListener("click", function(e){
      e.stopPropagation();
    });

    // make the close button
    var closeButton = document.createElement("div");
    closeButton.id = "mp__close-advanced-player";
    closeButton.addEventListener("click", function(e){
      self._closeAdvancedPlayer();
    }, false);

    titleBar.appendChild(closeButton);

    var zoomControl = document.createElement("div");
    zoomControl.id = "mp__zoom-control";

    // TODO: zoom control

    return titleBar;
  },

  /**
   * Creates the video tag used by the advanced player
   *
   * @param    {String}       src
   *
   * @returns  {Node}
   */
  _createVideoTag: function(src){
    var self = this;

    // set up video tag
    var video = document.createElement("video");
    video.id = "mp__video";
    video.setAttribute("src", src);

    if(this.options.autoloop){
      video.setAttribute("loop", true);
    }

    self._bindKeyboardShortcuts(video);

    // dispatch a final video time event when the video ends
    video.addEventListener("ended", function(e){
      self._dispatchVideoTime(video);
    }, false);

    return video;
  },

  /**
   * Creates all controls for the advanced player
   *
   * @param    {Node}         videoNode
   * @param    {Object}       videoData
   *
   * @returns  {Node}
   */
  _createVideoControls: function(videoNode, videoData){
    var self = this;

    // set up the video controls container
    var videoControlsContainer = document.createElement("div");
    videoControlsContainer.id = "mp__video-controls-container";

    // prevent any click that gets to the videoControlsContainer form
    // propagating up any farther and closing the player
    videoControlsContainer.addEventListener("click", function(e){
      e.stopPropagation();
    });

    var playPauseButton = self._createPlayPauseButton(videoNode);
    var currentTimeCounter = self._createCurrentTimeCounter(videoNode);
    var seekBar = self._createSeekBar(videoNode, videoData);
    var totalTimeCounter = self._createTotalTimeCounter(videoNode);
    var playbackSpeedControl = self._createPlaybackSpeedControl(videoNode);

    // add controls to video controls container
    videoControlsContainer.appendChild(playPauseButton);
    videoControlsContainer.appendChild(currentTimeCounter);
    videoControlsContainer.appendChild(seekBar);
    videoControlsContainer.appendChild(totalTimeCounter);
    videoControlsContainer.appendChild(playbackSpeedControl);

    return videoControlsContainer;
  },

  /**
   * Creates the play/pause control for the advanced player
   *
   * @param    {Node}         video
   *
   * @returns  {Node}
   */
  _createPlayPauseButton: function(video){
    var self = this;

    // set up play/pause button
    var playPauseButton = document.createElement("div");
    playPauseButton.id = "mp__play-pause";
    playPauseButton.addEventListener("click", function(e){
      e.stopPropagation();

      // TODO: Do we need to do this check here?
      if(video !== undefined){
        if (video.paused == true) {
          video.play();
        } else {
          video.pause();
        }
      } else {
        // TODO: Throw error/warning if video is undeinfed
      }
    }, false);

    video.addEventListener("play", function(e){
      self.__addClass(playPauseButton, "playing");
      self._startVideoTimeDispatcher(video);
    }, false);

    video.addEventListener("pause", function(e){
      self.__removeClass(playPauseButton, "playing");
      self._stopVideoTimeDispatcher();
    }, false);

    return playPauseButton;
  },

  /**
   * Creates the current time counter control for the advanced player
   *
   * @param    {Node}         video
   *
   * @returns  {Node}
   */
  _populateTimeNode: function(timeNode, timeInSeconds){
    var self = this;

    var timeObj = self.__getTimeObject(timeInSeconds);
    timeNode.innerHTML =
        timeObj.minutesStr + ":" + timeObj.secondsStr;

    var msNode = document.createElement("span");
    self.__addClass(msNode, "ms__time-ms");
    msNode.innerHTML = timeObj.msStr;

    timeNode.appendChild(msNode);

    return timeNode;
  },

  /**
   * Creates the current time counter control for the advanced player
   *
   * @param    {Node}         video
   *
   * @returns  {Node}
   */
  _createCurrentTimeCounter: function(video){
    var self = this;

    var currentTimeCounter = document.createElement("div");
    currentTimeCounter.id = "mp__current-time-counter"

    self._populateTimeNode(currentTimeCounter, video.currentTime);

    video.addEventListener("MP_timeupdate-granular", function(e){
      self._populateTimeNode(currentTimeCounter, e.detail);
    }, false);

    return currentTimeCounter;
  },

  /**
   * Creates the total time counter control for the advanced player
   *
   * @param    {Node}         video
   *
   * @returns  {Node}
   */

  _createTotalTimeCounter: function(video){
    var self = this;

    var totalTimeCounter = document.createElement("span");
    totalTimeCounter.id = "mp__total-time-counter"

    // Wait until metadata is loaded to get video duration, otherwise
    // we'll get NaN here (lame)
    video.addEventListener("loadedmetadata", function(e){
      self._populateTimeNode(totalTimeCounter, video.duration);
    }, false);

    return totalTimeCounter;
  },

  /**
   * Creates the seek bar control for the advanced player
   *
   * @param    {Node}         video
   * @param    {Object}       videoData
   *
   * @returns  {Node}
   */
  _createSeekBar: function(video, videoData){
    var self = this;

    // set up seek bar container
    var seekBarContainer = document.createElement("div");
    seekBarContainer.id = "mp__seek-bar-container";

    // set up seek bar
    var seekBar = document.createElement("input");
    seekBar.id = "mp__seek-bar";
    seekBar.type = "range";
    seekBar.value = 0;

    // event listener for the seek bar
    seekBar.addEventListener("input", function(e) {
      e.stopPropagation();

      // calculate the new time
      var time = video.duration * (seekBar.value / 100);

      // update the video time
      video.currentTime = time;

      // and send a MS_timeupdate-granular event (the video is paused here, so
      // we otherwise wouldn't get it)
      self._dispatchVideoTime(video);

    });

    if(videoData.mpMarkedZones){

      // create marked zones container
      var markedZonesContainer = document.createElement("div");
      markedZonesContainer.id = "mp__marked-zones-container";

      // parse the marked zones out of the video data
      var markedZones = self._parseMarkedZones(videoData.mpMarkedZones);

      // need to wait for video loaded metadata, otherwise duration is NaN
      // populate marked zones
      video.addEventListener("loadedmetadata", function(e){
        markedZones.forEach(function(zone, i){
          // create the marked zone
          var markedZone = document.createElement("div");
          self.__addClass(markedZone, "mp__marked-zone");

          // set its left
          var leftPercentage = ((zone.start/video.duration) * 100) + "%";
          markedZone.style.left = leftPercentage;

          // set its width
          var markedZoneDuration = zone.end - zone.start;
          var widthPercentage = ((markedZoneDuration/video.duration) * 100) + "%";
          markedZone.style.width = widthPercentage;

          // this is the bar that sits on top of the seek bar, and should have
          // pointer events (so they can pass through to the seek bar)
          var markedZoneBar = document.createElement("div");
          self.__addClass(markedZoneBar, "mp__marked-zone-bar");

          // this is the bar that sits *below* the seek bar, and has the click
          // handler to jump to the marked zone's start time
          var markedZoneHandle = document.createElement("div");
          self.__addClass(markedZoneHandle, "mp__marked-zone-handle");

          if(zone.name){
            markedZoneHandle.innerHTML = zone.name;
          }

          markedZone.appendChild(markedZoneBar);
          markedZone.appendChild(markedZoneHandle);

          markedZoneHandle.addEventListener("click", function(e){
            video.currentTime = zone.start;
            self._dispatchVideoTime(video);
          }, false);

          markedZonesContainer.appendChild(markedZone);
        });
      }, false);

      seekBarContainer.appendChild(markedZonesContainer);
    }

    // OPTION 1: Update slider based on timeupdate
    // video.addEventListener("timeupdate", function() {
    //   console.log("timeupdate");
    //   // Calculate the slider value
    //   var value = (100 / video.duration) * video.currentTime;

    //   // Update the slider value
    //   seekBar.value = value;
    // });

    // OPTION 2: Update slider based on setInterval
    video.addEventListener("MP_timeupdate-granular", function(){
      // Calculate the slider value
      var value = (100 / video.duration) * video.currentTime;

      // Update the slider value
      seekBar.value = value;
    }, false);

    // pause the video when the slider handle is being dragged
    seekBar.addEventListener("mousedown", function() {
      video.pause();
    });

    if(self.options.playAfterSeek){
      // play the video when the slider handle is dropped
      seekBar.addEventListener("mouseup", function() {
        video.play();
      });
    }

    seekBarContainer.appendChild(seekBar);

    return seekBarContainer;
  },

  /**
   * Given the string data- attr for the marked zones, parses it into an
   * array of markedZone objects
   *
   * @param    {String}       zonesStr
   *
   * @returns  {Array}
   */
  _parseMarkedZones: function(zonesStr){
    var zonesObj = [];
    // split the single string into an array of strings each representing
    // a single marked zone
    var zoneStrings = zonesStr.split(",").map(function(str){return str.trim()});

    zoneStrings.forEach(function(zoneStr){
      var zoneData = zoneStr.split("-").map(function(str){return str.trim()});
      var zoneObj = {
        "start": zoneData[0],
        "end": zoneData[1],
        "name": zoneData[2]
      }
      zonesObj.push(zoneObj);
    });
    return zonesObj;
  },

  /**
   * Starts the setInterval that dispatches the more granular video timeupdate
   * events, and places a reference to it on the MotionPlayer instance
   *
   * @param    {Node}         video
   *
   * @returns  {undefined}
   */
  _startVideoTimeDispatcher: function(video){
    var self = this;

    self.videoTimeDispatcher = setInterval(function(){
      self._dispatchVideoTime(video);
    }, self.options.videoTimeUpdateGranularity);
  },

  /**
   * Clears the videoTimeDispatcher setInterval, which was stored on the
   * MotionPlayer instance when it was started in _startVideoTimeDispatcher
   *
   * @param    {Node}         video
   *
   * @returns  {undefined}
   */
  _stopVideoTimeDispatcher: function(){
    var self = this;
    clearInterval(self.videoTimeDispatcher);
  },

  /**
   * Dispatches a single MP_timeupdate-granular event
   *
   * @param    {Node}         video
   *
   * @returns  {undefined}
   */
  _dispatchVideoTime: function(video){
    // Must use the "detail" property here evidently :/
    var event = new CustomEvent("MP_timeupdate-granular", {
      detail: video.currentTime
    });
    video.dispatchEvent(event);
  },

  /**
   * Creates the playbackSpeed control for the advanced player
   *
   * @param    {Node}         video
   *
   * @returns  {Node}
   */
  _createPlaybackSpeedControl: function(video){
    var self = this;

    var playbackSpeedControl = document.createElement("div");
    playbackSpeedControl.id = "mp__playback-speed";
    self.__addClass(playbackSpeedControl, "mp__select-control");

    var speedFull = document.createElement("span");
    speedFull.innerHTML = "Full Speed";
    speedFull.dataset.rate = 1;
    this.__addClass(speedFull, "mp__full-speed");
    this.__addClass(speedFull, "mp__select-control-selected");

    var speedHalf = document.createElement("span");
    speedHalf.innerHTML = "&frac12;"
    speedHalf.dataset.rate = 0.5;

    var speedQuarter = document.createElement("span");
    speedQuarter.innerHTML = "&frac14;"
    speedQuarter.dataset.rate = 0.25;

    var speedEigth = document.createElement("span");
    speedEigth.innerHTML = "&#8539;"
    speedEigth.dataset.rate = 0.125;

    var allSpeeds = [speedFull, speedHalf, speedQuarter, speedEigth];
    this.__addEventListenerList(allSpeeds, "click", function(){
      // remove selected class from all
      allSpeeds.forEach(function(speed, i){
        self.__removeClass(speed, "mp__select-control-selected");
      });

      // add selected class to clicked speed
      self.__addClass(this, "mp__select-control-selected");

      // set video to that speed
      video.playbackRate = this.dataset.rate;
    });

    playbackSpeedControl.appendChild(speedFull);
    playbackSpeedControl.appendChild(speedHalf);
    playbackSpeedControl.appendChild(speedQuarter);
    playbackSpeedControl.appendChild(speedEigth);

    return playbackSpeedControl;
  },

  _bindKeyboardShortcuts: function(video){
    var self = this;
    // NOTE: We need to have both a keydown and a keyup handler here because:
    //    (a) we can only detect ESC with a keyup (it doesn't fire keydown)
    //    (b) we can only prevent the space bar from scrolling the webpage
    //        with a keydown, since that is apparently the event that triggers
    //        it, *not* the keyup

    // store a refernces to the "bound" versions of these event handler so that
    // we can remove them later
    self.keyupHandlerReference = self._keyupHandler.bind(this);
    self.keydownHandlerReference = self._keydownHandler.bind(this);

    window.addEventListener("keyup", self.keyupHandlerReference, false);
    window.addEventListener("keydown", self.keydownHandlerReference, false);
  },

  _unbindKeyboardShorcuts: function(){
    var self = this;
    window.removeEventListener("keyup", self.keyupHandlerReference, false);
    window.removeEventListener("keydown", self.keydownHandlerReference, false);
  },

  _keyupHandler: function(e){
    var self = this;

    e.stopPropagation();
    e.preventDefault();

    // NOTE: Some events are also bound on keydown -- please see the comment in
    // _bindKeyboardShortcuts for the reason

    var keyCode = e.which;
    switch(keyCode){
      case 27: // ESC KEY
        self._closeAdvancedPlayer();
        break;
      default:
        break;
    }
    return false;
  },

  _keydownHandler: function(e){
    var self = this;

    e.preventDefault();

    // NOTE: Some events are also bound on keyup -- please see the comment in
    // _bindKeyboardShortcuts for the reason

    var keyCode = e.which;
    switch(keyCode){
      case 32: // SPACE BAR
        // don't think we can pass the video in here due the weirdness around
        // passing extra parameters to click handlers, so we'll have to use
        // getCurrentVideo() function
        var video = self._getCurrentVideo();
        if(video.paused){
          video.play()
        } else {
          video.pause();
        }
        break;
      default:
        break;
    }
    return false;
  },

  /**
   * Returns the video currently open in the advanced player, or undefined
   * if no advanced player is open
   *
   * @returns  {Node/undefined}
   */
  _getCurrentVideo: function(){
    return document.getElementById("mp__video");
  },

  /**
   * Prints the current state of the plugin to the console
   *
   * @returns  {undefined}
   */
  _dumpState: function() {
    console.log("State Dump -----------------------------------------");
    // Output any needed state here
    console.log("----------------------------------------------------");
  },


  /*---------------------------------------------------------------------------/
  |  PUBLIC FUNCTIONS                                                         /
  ---------------------------------------------------------------------------/
  |  These functions are exposed and called directly from the instance,     /
  |  and therefore do not need .call(this)                                 /
   ----------------------------------------------------------------------*/

  /**
   * Foobar
   *
   */
  doSomething: function(){

  }

};